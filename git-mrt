#!/bin/bash

# Exit with return code
# $1 - message to output in stderr
# $2 - return code
function die() {
    echo "$1" >&2
    exit ${2:-1}
}

function usage() {
    printf "Usage: %s [-m|--monolocation <dir>] [-d|--deploykeyfile <file>] command\n" `basename $0`
    echo "
Available options:
 -h or --help                       - show this help
 -m or --monolocation               - local directory where the monorepo will be cloned
 -d or --deploykeyfile              - private deploy key to use for monorepo clone
 -p or --pinch                      - treat the subdir as a simple set of files and not a repo (no history)

Available commands:
  clone <subdir_in_monorepo>           - extract a monorepo subdirectory as a subtree repo
  push [subdir_in_monorepo]            - push local subtree repo changes as a monorepo branch
  pull [subdir_in_monorepo]            - update local subtree repo from a monorepo subdirectory"
    exit 1
}

MRLOC=~/.monorepo
EXTREPONAME=app-deploy-epics
EXTREPOLOC=https://github.com/NSLS2/$EXTREPONAME.git
EXTREPOLOCGIT=git@github.com:NSLS2/$EXTREPONAME.git

function check_uncommited_changes () {
    num_uncommited_changes=$(git status -s --untracked-files=no | wc -l)
    if [ "$num_uncommited_changes" != "0" ]; then
        git status --untracked-files=no
        die "$PWD is a git repository but has uncommited changes! Commit them first before pushing or pulling."
    fi
}

function sparse_pull_mono() {
    # have to install the package 'git-subtree' for the command 'git subtree'
    git subtree &> /dev/null
    [ $? -ne 129 ] && die "ERROR: git-subtree is not installed"
    # $1 - subdirectory to sparse-checkout
    [ ! -d $MRLOC ] && mkdir -p $MRLOC
    cd $MRLOC
    if [ ! -d $EXTREPONAME ]; then
        if [ ! "$DEPLOYKEYFILE" ]; then
            git clone --depth 1 --filter=blob:none --sparse $EXTREPOLOC
        else
            git clone -c core.sshCommand="/usr/bin/ssh -i $DEPLOYKEYFILE" --depth 1 --filter=blob:none --sparse $EXTREPOLOCGIT
        fi
    fi
    cd $EXTREPONAME
    [ ! -d .git ] && die "$MRLOC/$EXTREPONAME exists but is not a git repository, determine the cause manually"
    git sparse-checkout set $1
    git pull
}

function mrt__clone() {
    if [ "$1" ]; then
        local subdirectory=$1
    else
        die 'ERROR: Must specify a subdirectory to use the git mrt clone method.'
    fi
    if [ ! "$TARGET" ]; then
        TARGET=$(pwd)/`basename $subdirectory`
    fi
    [ -d $TARGET ] && die "ERROR: $TARGET already exists, specify an alternative with --target"

    sparse_pull_mono $subdirectory

    [ ! -d $subdirectory ] && die "ERROR: No repository with the directory $subdirectory in $EXTREPONAME"

    if [ -n "$PINCH" ]; then
        cp -r $subdirectory $TARGET
        cd $TARGET
        echo "$subdirectory" > .mrt
    else
        git subtree split -P $subdirectory --annotate='(split) ' --rejoin -b $subdirectory/split
        mkdir $TARGET
        cd $TARGET
        git init
        git pull $MRLOC/$EXTREPONAME $subdirectory/split
        echo "$subdirectory" > .mrt
        echo ".mrt" >> .gitignore
    fi
}

function mrt__pull() {
    # Remember the working directory
    local curdir=$(pwd)
    if [ -f .mrt ]; then
        # Subdir info must be present
        local subdirectory=$(<.mrt)
    else
        die 'ERROR: Cannot use git mrt pull outside of a directory created by git mrt clone.'
    fi
    # Using this would cause trouble if the dir is not a git repo (possible with --pinch)
    #REPOLOC=$(git rev-parse --show-toplevel)
    
    sparse_pull_mono $subdirectory

    [ ! -d $subdirectory ] && die "No repository with the directory $subdirectory in $EXTREPONAME"

    if [ -n "$PINCH" ]; then
        # Pinch mode - just copy files over
        cp -r $MRLOC/$EXTREPONAME/$subdirectory/* $curdir/.
    else
        # Subtree mode - split in monorepo and then pull from there
        git subtree split -P $subdirectory --annotate='(split) ' --rejoin -b $subdirectory/split
        cd $curdir
        git pull $MRLOC/$EXTREPONAME $subdirectory/split
    fi
}

function mrt__push() {
    # Remember the working directory
    local curdir=$(pwd)
    # Use subdir from metadata if available
    if [ -f .mrt ]; then
        local subdirectory=$(<.mrt)
    # Use explicit subdir if no metadata
    elif [ "$1" ]; then
        subdirectory=$1
    else
        die 'ERROR: Must specify a subdirectory to use the git mrt push command if not in a directory created by git mrt clone.'
    fi

    if [ -n "$PINCH" ]; then
        BRANCH="pinch"
    else
        # We must be in a valid git repo now
        check_uncommited_changes
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        REPOLOC=$(git rev-parse --show-toplevel)
    fi
    
    sparse_pull_mono $subdirectory

    # Figure out the monorepo branch to work on
    if [ ! $TARGETBRANCH ]; then
        TARGETBRANCH=$subdirectory/$BRANCH
    fi
    EXISTS=$(git branch | grep -w $TARGETBRANCH)
    if [[ $EXISTS ]]; then
        git checkout $TARGETBRANCH
    else
        git checkout -b $TARGETBRANCH
    fi

    if [ -n "$PINCH" ]; then
        # In pinch mode, copy files and commit directly
        if [ -d $subdirectory ]; then
            cp -r $curdir/* $MRLOC/$EXTREPONAME/$subdirectory/.
        else
            cp -r $curdir $MRLOC/$EXTREPONAME/$subdirectory
        fi
        cd $MRLOC/$EXTREPONAME/$subdirectory
        git add .
        # TODO: customized commit message
        git commit -m "Pinch commit of subdirectory $subdirectory"
    else
        # Subtree mode - commit is created by pull/add
        if [ -d $subdirectory ]; then
            git subtree pull -P $subdirectory $REPOLOC $BRANCH
        else
            git subtree add -P $subdirectory $REPOLOC $BRANCH
        fi
    fi

    # Push absorbed changes in a monorepo branch
    git push --set-upstream origin $TARGETBRANCH
    git checkout main
}

function mrt_main() {
    while :; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -p|--pinch)
                PINCH=1
                shift
                ;;
            -m|--monolocation)
                if [ "$2" ]; then
                    MRLOC=$2
                    shift 2
                else
                    die 'ERROR: "--monolocation (-m)" requires a non-empty option argument'
                fi
                ;;
            -d|--deploykeyfile)
                if [ "$2" ]; then
                    DEPLOYKEYFILE=$2
                    shift 2
                else
                    die 'ERROR: "--deploykeyfile (-d)" requires a non-empty option argument'
                fi
                ;;
            clone|pull|push)
                local cmdname=$1; shift
                "mrt__$cmdname" "$@"
                break
                ;;
            "")
                echo 'ERROR: no command is specified'
                usage
                ;;
            *)
                echo "ERROR: unknown command or option: $1"
                usage
                ;;
        esac
    done
}

mrt_main $@
