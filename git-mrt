#!/bin/bash

# Exit with return code
# $1 - message to output in stderr
# $2 - return code
function die() {
    echo "$1" >&2
    exit ${2:-1}
}

declare -A LOG_LEVELS
LOG_LEVELS=([0]="ERROR" [1]="WARN" [2]="INFO" [3]="DEBUG")

VERBOSITY=2

function log() {
    if [ "$#" -eq 0 ]; then
        die "ASSERT: log() called with no arguments"
    elif [ "$#" -eq 1 ]; then
        # default to INFO level if not set
        local level=2
    else
        local level=${1}
        shift
    fi
    if [ "$VERBOSITY" -ge "$level" ]; then
        printf "[${LOG_LEVELS[$level]}] $@\n"
    fi
}

function usage() {
    printf "Usage: %s [-m|--monolocation <dir>] [-d|--deploykeyfile <file>] command\n" `basename $0`
    echo "
Available options:
  -h or --help                         - show this help
  -m or --monolocation                 - local directory where the monorepo will be cloned
  -d or --deploykeyfile                - private deploy key to use for monorepo clone
  -p or --pinch                        - treat the subdir as a simple set of files and not a repo (no history)
  -n or --nosquash                     - perform history rejoin on clone and do not squash commits on push

Available commands:
  clone <subdir_in_monorepo>           - extract a monorepo subdirectory as a subtree repo
  push [subdir_in_monorepo]            - push local subtree repo changes as a monorepo branch
  pull [subdir_in_monorepo]            - update local subtree repo from a monorepo subdirectory"
    exit 1
}

# Location to which monorepo is cloned
MONOHOME=~/.monorepo
# Name of the cloned repository
MONODIR=app-deploy-epics
# Actual path to the local monorepo
MONOPATH=$MONOHOME/$MONODIR
# Clone link - https default
MONOHTTPSLINK=https://github.com/NSLS2/$MONODIR.git
# Clone link - when using deploy key
MONOGITLINK=git@github.com:NSLS2/$MONODIR.git

function check_uncommited_changes () {
    log "Checking for uncommited changes in local subrepo"
    num_uncommited_changes=$(git status -s --untracked-files=no | wc -l)
    if [ "$num_uncommited_changes" != "0" ]; then
        git status --untracked-files=no
        die "[FATAL] $PWD is a git repository but has uncommited changes! Commit them first before pushing or pulling"
    fi
}

function sparse_pull_mono() {
    log "Creating and validating local monorepo"

    # Remember original dir
    pushd ${PWD} &> /dev/null

    # have to install the package 'git-subtree' for the command 'git subtree'
    git subtree &> /dev/null
    [ $? -ne 129 ] && die "[FATAL] git-subtree is not installed"

    # $1 - subdirectory to sparse-checkout
    if [ ! -d $MONOHOME ]; then
        mkdir -p $MONOHOME
        [ ! -d $MONOHOME ] && die "[FATAL] Failed to create $MONOHOME"
    fi

    cd $MONOHOME
    if [ ! -d $MONODIR ]; then
        if [ ! "$DEPLOYKEYFILE" ]; then
            log "Cloning monorepo from $MONOHTTPSLINK"
            git clone --depth 1 --filter=blob:none --sparse $MONOHTTPSLINK
        else
            log "Cloning monorepo from $MONOGITLINK"
            git clone -c core.sshCommand="/usr/bin/ssh -i $DEPLOYKEYFILE" --depth 1 --filter=blob:none --sparse $MONOGITLINK
        fi
        if [ $? -ne 0 ]; then
            die "[FATAL] Monorepo clone failed"
        fi
    fi

    cd $MONODIR
    [ ! -d .git ] && die "[FATAL] $MONOPATH exists but is not a git repository, determine the cause manually"

    log "Performing monorepo sparse checkout"
    git sparse-checkout set $1
    [ $? -ne 0 ] && die "[FATAL] Monorepo sparse-checkout failed"

    log "Pulling monorepo updates"
    git pull
    [ $? -ne 0 ] && die "[FATAL] Monorepo pull failed"

    # Restore original dir
    popd &> /dev/null
}

function mrt__clone() {
    if [ "$1" ]; then
        local subdirectory=$1
    else
        die 'ASSERT: mrt__clone() is called without subdirectory argument being specified'
    fi

    log "Preparing to extract monorepo subdir as local subrepo"

    local subrepopath="$(pwd)/`basename $subdirectory`"
    [ -d $subrepopath ] && die "[FATAL] `basename $subdirectory` directory already exists"

    sparse_pull_mono $subdirectory

    [ ! -d $MONOPATH/$subdirectory ] && die "[FATAL] Monorepo $MONODIR does not contain subdirectory $subdirectory"

    if [ -n "$PINCH" ]; then
        log "Extracting local subrepo in pinch mode"
        cp -r $MONOPATH/$subdirectory $subrepopath
        [ $? -ne 0 ] && die "[FATAL] Failed to copy files from the monorepo"
        cd $subrepopath
        echo "$subdirectory" > .mrt
    else
        log "Extracting local subrepo by monorepo git subtree split"
        # git subtree extra args
        local steargs="--rejoin"
        # Always do rejoin for now. That results in extra split commits to be generated every time
        # clone is used if the local monorepo is not checked out already. This is necessary however
        # for push to work, as it requires knowledge about prior split. TODO: figure out how to work
        # without --rejoin. Note that pull command also does rejoin.
        #if [ -n "$NOSQUASH" ]; then
        #    steargs="--rejoin"
        #fi
        cd $MONOPATH
        git subtree split $steargs -P $subdirectory --annotate='(split) ' -b $subdirectory/split
        [ $? -ne 0 ] && die "[FATAL] git subtree split failed"

        log "Initializing and pulling the local subrepo"
        mkdir $subrepopath
        [ $? -ne 0 ] && die "[FATAL] Failed to create the subrepo dir"
        cd $subrepopath
        git init
        git pull $MONOPATH $subdirectory/split
        [ $? -ne 0 ] && die "[FATAL] Failed to pull the local subrepo from the local monorepo"
        echo "$subdirectory" > .mrt
        echo ".mrt" >> .gitignore
    fi
    log "Local subrepo clone complete"
}

function mrt__pull() {
    log "Preparing to pull local subrepo updates from the monorepo"
    # Remember the working directory
    local subrepopath=$(pwd)
    if [ -f .mrt ]; then
        # Subdir info must be present
        local subdirectory=$(<.mrt)
    else
        die "[FATAL] Cannot find local subrepo metadata. Was it created by 'git mrt clone'?"
    fi
    # Using this would cause trouble if the dir is not a git repo (possible with --pinch)
    #subrepoloc=$(git rev-parse --show-toplevel)

    sparse_pull_mono $subdirectory

    [ ! -d $MONOPATH/$subdirectory ] && die "[FATAL] Monorepo $MONODIR does not contain subdirectory $subdirectory"

    if [ -n "$PINCH" ]; then
        # Pinch mode - just copy files over
        log "Updating local subrepo in pinch mode"
        cp -r $MONOPATH/$subdirectory/* $subrepopath/.
        [ $? -ne 0 ] && die "[FATAL] Failed to copy files from the monorepo"
    else
        # Subtree mode - split in monorepo and then pull from there
        log "Updating local subrepo from monorepo git subtree split"
        cd $MONOPATH
        git subtree split -P $subdirectory --annotate='(split) ' --rejoin -b $subdirectory/split
        cd $subrepopath
        log "Pulling local subrepo updates from the local monorepo"
        git pull $MONOPATH $subdirectory/split
        [ $? -ne 0 ] && die "[FATAL] Failed to pull from the local monorepo"
    fi
    log "Local subrepo pull complete"
}

function mrt__push() {
    log "Preparing to push local subrepo updates to the upstream monorepo"
    # Remember the working directory
    local subrepopath=$(pwd)
    # Use subdir from metadata if available
    if [ -f .mrt ]; then
        log "Using monorepo subdir from local subrepo metadata"
        local subdirectory=$(<.mrt)
    # Use explicit subdir if no metadata
    elif [ "$1" ]; then
        log "Using specified location as monorepo subdir"
        subdirectory=$1
    else
        die "[FATAL] Cannot determine target monorepo subdir, no metadata is found and no location is specified"
    fi

    log "Determining the relevant local subrepo branch"
    if [ -n "$PINCH" ]; then
        local subrepobranch="pinch"
    else
        # We must be in a valid git repo now
        check_uncommited_changes
        local subrepobranch=$(git rev-parse --abbrev-ref HEAD)
        local subrepoloc=$(git rev-parse --show-toplevel)
    fi

    sparse_pull_mono $subdirectory

    # Check if the containing subdir is already present in the index
    log "Ensuring that no intermediate subdirs will be created in the monorepo by the push"
    cd $MONOPATH
    git ls-files --error-unmatch $(dirname $subdirectory) &> /dev/null
    if [ $? -eq 1 ]; then
        die "[FATAL] performing the push would create a new intermediate monorepo subdir. Create '$MONODIR/$(dirname $subdirectory)' subdir in the monorepo directly"
    fi

    # Figure out if split branch exists
    # Do not use yet - it might be helpful to figure out if the local
    # monorepo corresponds to the subrepo, but the check will always fail
    # if we push a not-yet-imported dir
    #SPLITEXISTS=$(git branch | grep -w $subdirectory/split)
    #if [[ ! $SPLITEXISTS ]]; then
    #    die "ERROR: local monorepo doesn't have subrepo split"
    #fi

    log "Switching the local monorepo to a branch to be pushed"
    # Figure out the monorepo branch to work on
    local monorepobranch=$subdirectory/$subrepobranch
    git checkout $monorepobranch &> /dev/null || git checkout -b $monorepobranch

    if [ -n "$PINCH" ]; then
        log "Importing local subrepo files in pinch mode"
        if [ ! -d $MONOPATH/$subdirectory ]; then
            mkdir --parents $MONOPATH/$subdirectory
        fi
        # In pinch mode, copy files and commit directly
        if [ -d $subdirectory ]; then
            cp -r $subrepopath/* $MONOPATH/$subdirectory/.
        else
            cp -r $subrepopath $MONOPATH/$subdirectory
        fi
        cd $MONOPATH/$subdirectory
        git add .
        # TODO: customized commit message
        git commit -m "Pinch commit of subdirectory $subdirectory"
    else
        # git subtree extra args
        local steargs=""
        if [ -z "$NOSQUASH" ]; then
            steargs="--squash"
        fi
        # Subtree mode - commit is created by pull/add
        if [ -d $subdirectory ]; then
            log "Importing local subrepo changes to the existing monorepo dir with git pull"
            git subtree pull $steargs -P $subdirectory $subrepoloc $subrepobranch
        else
            log "Importing local subrepo changes to a new monorepo dir with git add"
            git subtree add $steargs -P $subdirectory $subrepoloc $subrepobranch
        fi
        if [ $? -ne 0 ]; then
            die "[FATAL] git subtree failed"
        fi
    fi

    # Push absorbed changes in a monorepo branch
    log "Pushing local monorepo changes to upstream"
    git push --set-upstream origin $monorepobranch
    [ $? -ne 0 ] && die "[FATAL] push to upstream failed"
    log "Switching local monorepo to main branch"
    git checkout main
    log "Local subrepo push complete"
}

function mrt_main() {
    POSITIONAL_ARGS=()
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -p|--pinch)
                PINCH=1
                shift
                ;;
            -m|--monolocation)
                if [ "$2" ]; then
                    MONOHOME=$2
                    shift 2
                else
                    die 'ERROR: -m|--monolocation requires a non-empty option argument'
                fi
                ;;
            -d|--deploykeyfile)
                if [ "$2" ]; then
                    DEPLOYKEYFILE=$2
                    shift 2
                else
                    die 'ERROR: -d|--deploykeyfile requires a non-empty option argument'
                fi
                ;;
            -n|--nosquash)
                NOSQUASH=1
                shift
                ;;
            clone|pull|push)
                if [ -z ${cmdname+x} ]; then
                    cmdname=$1
                    shift
                else
                    die "ERROR: '$1' command requested but '$cmdname' was already specified"
                fi
                ;;
            -*|--*)
                echo "ERROR: unknown option '$1'"
                usage
                ;;
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done

    set -- "${POSITIONAL_ARGS[@]}"

    if [ -z ${cmdname+x} ]; then
        echo "ERROR: no command is specified"
        usage
    fi
    "mrt__$cmdname" "$@"
}

mrt_main $@
