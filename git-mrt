#!/bin/bash

# Exit with return code
# $1 - message to output in stderr
# $2 - return code
function die() {
    echo "$1" >&2
    exit ${2:-1}
}

function usage() {
    printf "Usage: %s [-m|--monolocation <dir>] [-d|--deploykeyfile <file>] command\n" `basename $0`
    echo "
Available options:
  -h or --help                         - show this help
  -m or --monolocation                 - local directory where the monorepo will be cloned
  -d or --deploykeyfile                - private deploy key to use for monorepo clone
  -p or --pinch                        - treat the subdir as a simple set of files and not a repo (no history)
  -n or --nosquash                     - perform history rejoin on clone and do not squash commits on push

Available commands:
  clone <subdir_in_monorepo>           - extract a monorepo subdirectory as a subtree repo
  push [subdir_in_monorepo]            - push local subtree repo changes as a monorepo branch
  pull [subdir_in_monorepo]            - update local subtree repo from a monorepo subdirectory"
    exit 1
}

MRLOC=~/.monorepo
EXTREPONAME=app-deploy-epics
EXTREPOLOC=https://github.com/NSLS2/$EXTREPONAME.git
EXTREPOLOCGIT=git@github.com:NSLS2/$EXTREPONAME.git

function check_uncommited_changes () {
    num_uncommited_changes=$(git status -s --untracked-files=no | wc -l)
    if [ "$num_uncommited_changes" != "0" ]; then
        git status --untracked-files=no
        die "$PWD is a git repository but has uncommited changes! Commit them first before pushing or pulling"
    fi
}

function sparse_pull_mono() {
    # have to install the package 'git-subtree' for the command 'git subtree'
    git subtree &> /dev/null
    [ $? -ne 129 ] && die "ERROR: git-subtree is not installed"
    # $1 - subdirectory to sparse-checkout
    [ ! -d $MRLOC ] && mkdir -p $MRLOC
    cd $MRLOC
    if [ ! -d $EXTREPONAME ]; then
        if [ ! "$DEPLOYKEYFILE" ]; then
            git clone --depth 1 --filter=blob:none --sparse $EXTREPOLOC
        else
            git clone -c core.sshCommand="/usr/bin/ssh -i $DEPLOYKEYFILE" --depth 1 --filter=blob:none --sparse $EXTREPOLOCGIT
        fi
    fi
    cd $EXTREPONAME
    [ ! -d .git ] && die "$MRLOC/$EXTREPONAME exists but is not a git repository, determine the cause manually"
    git sparse-checkout set $1
    git pull
}

function mrt__clone() {
    if [ "$1" ]; then
        local subdirectory=$1
    else
        die 'ERROR: Must specify a subdirectory to use the git mrt clone method'
    fi
    if [ ! "$TARGET" ]; then
        TARGET=$(pwd)/`basename $subdirectory`
    fi
    [ -d $TARGET ] && die "ERROR: $TARGET already exists, specify an alternative with --target"

    sparse_pull_mono $subdirectory

    [ ! -d $subdirectory ] && die "ERROR: No repository with the directory $subdirectory in $EXTREPONAME"

    if [ -n "$PINCH" ]; then
        cp -r $subdirectory $TARGET
        cd $TARGET
        echo "$subdirectory" > .mrt
    else
        # git subtree extra args
        local steargs="--rejoin"
        # Always do rejoin for now. That results in extra split commits to be generated every time
        # clone is used if the local monorepo is not checked out already. This is necessary however
        # for push to work, as it requires knowledge about prior split. TODO: figure out how to work
        # without --rejoin. Note that pull command also does rejoin.
        #if [ -n "$NOSQUASH" ]; then
        #    steargs="--rejoin"
        #fi
        git subtree split $steargs -P $subdirectory --annotate='(split) ' -b $subdirectory/split
        mkdir $TARGET
        cd $TARGET
        git init
        git pull $MRLOC/$EXTREPONAME $subdirectory/split
        echo "$subdirectory" > .mrt
        echo ".mrt" >> .gitignore
    fi
}

function mrt__pull() {
    # Remember the working directory
    local curdir=$(pwd)
    if [ -f .mrt ]; then
        # Subdir info must be present
        local subdirectory=$(<.mrt)
    else
        die 'ERROR: Cannot use git mrt pull outside of a directory created by git mrt clone'
    fi
    # Using this would cause trouble if the dir is not a git repo (possible with --pinch)
    #REPOLOC=$(git rev-parse --show-toplevel)

    sparse_pull_mono $subdirectory

    [ ! -d $subdirectory ] && die "No repository with the directory $subdirectory in $EXTREPONAME"

    if [ -n "$PINCH" ]; then
        # Pinch mode - just copy files over
        cp -r $MRLOC/$EXTREPONAME/$subdirectory/* $curdir/.
    else
        # Subtree mode - split in monorepo and then pull from there
        git subtree split -P $subdirectory --annotate='(split) ' --rejoin -b $subdirectory/split
        cd $curdir
        git pull $MRLOC/$EXTREPONAME $subdirectory/split
    fi
}

function mrt__push() {
    # Remember the working directory
    local curdir=$(pwd)
    # Use subdir from metadata if available
    if [ -f .mrt ]; then
        local subdirectory=$(<.mrt)
    # Use explicit subdir if no metadata
    elif [ "$1" ]; then
        subdirectory=$1
    else
        die 'ERROR: Must specify a subdirectory to use the git mrt push command if not in a directory created by git mrt clone'
    fi

    if [ -n "$PINCH" ]; then
        BRANCH="pinch"
    else
        # We must be in a valid git repo now
        check_uncommited_changes
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        REPOLOC=$(git rev-parse --show-toplevel)
    fi

    sparse_pull_mono $subdirectory

    # Figure out the monorepo branch to work on
    if [ ! $TARGETBRANCH ]; then
        TARGETBRANCH=$subdirectory/$BRANCH
    fi

    # Figure out if split branch exists
    # Do not use yet - it might be helpful to figure out if the local
    # monorepo corresponds to the subrepo, but the check will always fail
    # if we push a not-yet-imported dir
    #SPLITEXISTS=$(git branch | grep -w $subdirectory/split)
    #if [[ ! $SPLITEXISTS ]]; then
    #    die "ERROR: local monorepo doesn't have subrepo split"
    #fi

    EXISTS=$(git branch | grep -w $TARGETBRANCH)
    if [[ $EXISTS ]]; then
        git checkout $TARGETBRANCH
    else
        git checkout -b $TARGETBRANCH
    fi

    if [ -n "$PINCH" ]; then
        # In pinch mode, copy files and commit directly
        if [ -d $subdirectory ]; then
            cp -r $curdir/* $MRLOC/$EXTREPONAME/$subdirectory/.
        else
            cp -r $curdir $MRLOC/$EXTREPONAME/$subdirectory
        fi
        cd $MRLOC/$EXTREPONAME/$subdirectory
        git add .
        # TODO: customized commit message
        git commit -m "Pinch commit of subdirectory $subdirectory"
    else
        # git subtree extra args
        local steargs=""
        if [ -z "$NOSQUASH" ]; then
            steargs="--squash"
        fi
        # Subtree mode - commit is created by pull/add
        if [ -d $subdirectory ]; then
            git subtree pull $steargs -P $subdirectory $REPOLOC $BRANCH
        else
            git subtree add $steargs -P $subdirectory $REPOLOC $BRANCH
        fi
        if [ $? -ne 0 ]; then
            die "ERROR: git subtree failed on push"
        fi
    fi

    # Push absorbed changes in a monorepo branch
    git push --set-upstream origin $TARGETBRANCH
    git checkout main
}

function mrt_main() {
    POSITIONAL_ARGS=()
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -p|--pinch)
                PINCH=1
                shift
                ;;
            -m|--monolocation)
                if [ "$2" ]; then
                    MRLOC=$2
                    shift 2
                else
                    die 'ERROR: -m|--monolocation requires a non-empty option argument'
                fi
                ;;
            -d|--deploykeyfile)
                if [ "$2" ]; then
                    DEPLOYKEYFILE=$2
                    shift 2
                else
                    die 'ERROR: -d|--deploykeyfile requires a non-empty option argument'
                fi
                ;;
            -n|--nosquash)
                NOSQUASH=1
                shift
                ;;
            clone|pull|push)
                if [ -z ${cmdname+x} ]; then
                    cmdname=$1
                    shift
                else
                    die "ERROR: '$1' command requested but '$cmdname' was already specified"
                fi
                ;;
            -*|--*)
                echo "ERROR: unknown option '$1'"
                usage
                ;;
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done

    set -- "${POSITIONAL_ARGS[@]}"

    if [ -z ${cmdname+x} ]; then
        echo "ERROR: no command is specified"
        usage
    fi
    "mrt__$cmdname" "$@"
}

mrt_main $@
