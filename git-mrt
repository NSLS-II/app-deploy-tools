#!/bin/bash

VERSION="0.1"

# Exit with return code
# $1 - message to output in stderr
# $2 - return code
function die() {
    echo "$1" >&2
    exit ${2:-1}
}

declare -A LOG_LEVELS
LOG_LEVELS=([0]="ERROR" [1]="WARN" [2]="INFO" [3]="DEBUG")

VERBOSITY=2

function log() {
    if [ "$#" -eq 0 ]; then
        die "ASSERT: log() called with no arguments"
    elif [ "$#" -eq 1 ]; then
        # default to INFO level if not set
        local level=2
    else
        local level=${1}
        shift
    fi
    if [ "$VERBOSITY" -ge "$level" ]; then
        printf "[${LOG_LEVELS[$level]}] $@\n"
    fi
}

function usage() {
    printf "Usage: %s [--version] [--help]
               [-m|--monolocation <dir>] [-d|--deploykeyfile <file>]
               [-a|--allowdirs]
               command [<args>]\n" `basename $0`
    echo "
Available options:
  -h or --help                         - show this help
  -m or --monolocation                 - local directory where the monorepo will be cloned
  -d or --deploykeyfile                - private deploy key to use for monorepo clone
  -a or --allowdirs                    - allow creation of new directories in monorepo on push
  -v or --version                      - show version

Available commands:
  clone <subdir_in_monorepo>           - extract a monorepo subdirectory as a local repo
  push [subdir_in_monorepo]            - push local repo changes as a monorepo branch
  pull [subdir_in_monorepo]            - update local repo from a monorepo subdirectory"
    exit 1
}

# Location to which monorepo is cloned
MONOHOME=~/.monorepo
# Name of the cloned repository
MONODIR=app-deploy-epics
# Actual path to the local monorepo
MONOPATH=$MONOHOME/$MONODIR
# Clone link - https default
MONOHTTPSLINK=https://github.com/NSLS2/$MONODIR.git
# Clone link - when using deploy key
MONOGITLINK=git@github.com:NSLS2/$MONODIR.git

function get_valid_subdirectory() {
    local subdir="$1"
    local _subdirectory="$1"
    [ -d ".git" ] && basepath="$(git config --get mrt.basepath)"

    if [ $# -ge 2 ]; then
        _subdirectory="$2"
        log "Using the specified location as the monorepo subdirectory"
    elif [ ! -z "$basepath" ]; then
        subdir=${basepath}/${PWD##*/}
        log "The monorepo subdirectory is constructed from the file .git/config"
    elif [ ! -z "${GIT_MRT_BASE_PATH+x}" ]; then
        subdir=$GIT_MRT_BASE_PATH/${PWD##*/}
        log "The monorepo subdirectory is constructed from the variable GIT_MRT_BASE_PATH"
    else
        die "[FATAL] Cannot determine the monorepo subdirectory.
        Must specify a subdirectory, Or type 'git config mrt.basepath base_path_in_monorepo',
        Or setup the environment variable GIT_MRT_BASE_PATH"
    fi

    # validate subdirectory by removing extra slashes; /acc/diag//diag-mc/ --> acc/diag/diag-mc
    subdir="$(echo "$subdir" | sed -E 's://*:/:g; s:^/?::g; s:/*$::g')"
    log "The monorepo subdirectory is validated to $subdir"

    # the eval statement below returns/sets the caller's variable subdirectory
    eval $_subdirectory="'$subdir'"
}

function check_uncommited_changes () {
    log "Checking for uncommited changes in local subrepo"
    num_uncommited_changes=$(git status -s --untracked-files=no | wc -l)
    if [ "$num_uncommited_changes" != "0" ]; then
        git status --untracked-files=no
        die "[FATAL] $PWD is a git repository but has uncommited changes!
        Commit them first before pushing or pulling"
    fi
}

function sparse_pull_mono() {
    # $1 - subdirectory to sparse-checkout
    log "Creating and validating local monorepo"

    # Remember original dir
    pushd ${PWD} &> /dev/null

    # have to install the python script 'git-filter-repo' for the command 'git filter-repo'
    git filter-repo --version &> /dev/null
    [ $? -ne 0 ] && die "[FATAL] Please install the script 'git-filter-repo' in your \$PATH
        (i.e. /usr/local/bin/git-filter-repo)"

    # Make sure that monorepo home dir exists
    if [ ! -d $MONOHOME ]; then
        mkdir -p $MONOHOME
        [ ! -d $MONOHOME ] && die "[FATAL] Failed to create $MONOHOME"
    fi
    cd $MONOHOME

    if [ -d $MONODIR ]; then
        # Sanity check in case if local monorepo dir already exists
        if [ ! -d $MONODIR/.git ]; then
            die "[FATAL] $MONOPATH exists but is not a git repository, determine the cause manually"
        fi
    fi

    # Clone the monorepo if it is absent
    if [ ! -d $MONODIR ]; then
        #local gceargs="--filter=blob:none --sparse"
        local gceargs="--sparse"
        if [ ! "$DEPLOYKEYFILE" ]; then
            log "Cloning monorepo from $MONOHTTPSLINK"
            git clone $gceargs $MONOHTTPSLINK
        else
            log "Cloning monorepo from $MONOGITLINK"
            git clone -c core.sshCommand="/usr/bin/ssh -i $DEPLOYKEYFILE" $gceargs $MONOGITLINK
        fi
        if [ $? -ne 0 ]; then
            die "[FATAL] Monorepo clone failed"
        fi
    fi
    cd $MONODIR

    log "Performing monorepo sparse checkout"
    git sparse-checkout set $1
    [ $? -ne 0 ] && die "[FATAL] Monorepo sparse-checkout failed"

    log "Checking for monorepo updates"
    git pull -q origin main
    [ $? -ne 0 ] && die "[FATAL] Monorepo pull failed"

    # Restore original dir
    popd &> /dev/null
}

function mrt__clone() {
    if [ "$1" ]; then
        local subdirectory=$1
    else
        die 'ASSERT: mrt__clone() is called without subdirectory argument being specified'
    fi

    log "Preparing to extract monorepo subdir as local subrepo"
    get_valid_subdirectory $1 subdirectory
    local subrepopath="$(pwd)/`basename $subdirectory`"
    [ -d $subrepopath ] && die "[FATAL] `basename $subdirectory` directory already exists"
    sparse_pull_mono $subdirectory
    [ ! -d $MONOPATH/$subdirectory ] && die "[FATAL] Monorepo $MONODIR does not contain $subdirectory"

    log "Extracting the subdirectory into a monorepo branch"
    cd $MONOPATH
    #git subtree push -P $subdirectory $subrepopath split
    #git subtree split --annotate='(split) ' -P $subdirectory -b $subdirectory/split
    #git filter-repo --force --subdirectory-filter "$subdirectory" --refs "$subdirectory" 
    git checkout -b filter-repo || die "[FATAL] Failed to create filter-repo branch"
    git filter-repo --force --subdirectory-filter "$subdirectory" --refs filter-repo 
    if [ $? -ne 0 ]; then
        git checkout -q main
        git branch -q -D filter-repo
        die "[FATAL] Failed to perform filter-repo, check subdirectory name"
    fi

    log "Initializing a subrepo"
    mkdir $subrepopath || die "[FATAL] Failed to create the subrepo dir"
    cd $subrepopath && git init -q

    log "Pulling the monorepo filter-repo branch into the subrepo"
    git pull -q $MONOPATH filter-repo
    if [ $? -ne 0 ]; then
        rm -fR $subrepopath || echo "Failed to clean up the subrepo dir"
        log "Pull in the subrepo failed"
    fi

    log "Cleaning up the monorepo filter-repo branch"
    cd $MONOPATH
    git checkout -q main
    git branch -q -D filter-repo

    log "Writing subrepo metadata"
    cd $subrepopath
    git config mrt.basepath "$( dirname $subdirectory)"

    log "Local subrepo clone complete"
}

function mrt__pull() {
    die "Sorry, not implemented yet"
    log "Preparing to pull local subrepo updates from the monorepo"
    # Remember the working directory
    local subrepopath=$(pwd)
    [ ! -d ".git" ] && die "[FATAL] $subrepopath is not a git repository"

    get_valid_subdirectory $1 subdirectory

    # Using this would cause trouble if the dir is not a git repo (possible with --pinch)
    #subrepoloc=$(git rev-parse --show-toplevel)
    sparse_pull_mono $subdirectory

    [ ! -d $MONOPATH/$subdirectory ] && die "[FATAL] Monorepo $MONODIR does not contain $subdirectory"
    # Subtree mode - split in monorepo and then pull from there
    log "Updating local subrepo from monorepo git subtree split"
    cd $MONOPATH
    git subtree split --annotate='(split) ' -P $subdirectory -b $subdirectory/split
    cd $subrepopath
    log "Pulling local subrepo updates from the local monorepo"
    git pull $MONOPATH $subdirectory/split
    local pull_success=$?
    if [ $pull_success -ne 0 ]; then
        die "[FATAL] Failed to pull from the local monorepo"
    fi

    cd $MONOPATH
    git branch -D -q $subdirectory/split
    cd $subrepopath
    log "Local subrepo pull complete"
}

function mrt__push() {
    die "Sorry, not implemented yet"
    log "Preparing to push local subrepo updates to the upstream monorepo"
    # Remember the working directory
    local subrepopath=$(pwd)
    [ ! -d ".git" ] && die "[FATAL] $subrepopath is not a git repository"

    get_valid_subdirectory $1 subdirectory

    log "Determining the relevant local subrepo branch"
    # We must be in a valid git repo now
    check_uncommited_changes
    local subrepobranch=$(git rev-parse --abbrev-ref HEAD)
    local subrepoloc=$(git rev-parse --show-toplevel)
    
    sparse_pull_mono $subdirectory

    # Check if the containing subdir is already present in the index
    log "Ensuring that no intermediate subdirs will be created in the monorepo by the push"
    cd $MONOPATH
    git ls-files --error-unmatch $(dirname $subdirectory) &> /dev/null
    if [ $? -eq 1 ] && [ ! -n "$ALLOWDIRS" ]; then
        die "[FATAL] Performing the push would create a new intermediate monorepo subdir.
        Create '$(dirname $subdirectory)' subdir in the upstream monorepo directly,
        or allow subdir creation with --allowdirs"
    fi

    log "Switching the local monorepo to a branch to be pushed"
    # Figure out the monorepo branch to work on
    local monorepobranch=$subdirectory/$subrepobranch
    git checkout "$monorepobranch" &> /dev/null || git checkout -b "$monorepobranch"
    [ $? -ne 0 ] && die "[FATAL] branch switch failed, check subdirectory name"

    # git subtree extra args
    local steargs=""
    if [ -d $subdirectory ]; then
        log "Importing local subrepo changes to the existing monorepo dir with git subtree pull"
        git subtree pull $steargs -P $subdirectory $subrepoloc $subrepobranch
        local _success=$?
    else
        log "Importing local subrepo changes to a new monorepo dir with git add"
        git subtree add $steargs -P $subdirectory $subrepoloc $subrepobranch
        local _success=$?
    fi

    if [ $_success -ne 0 ]; then
        git checkout -q main
        git branch -D -q "$monorepobranch"
        die "[FATAL] git subtree failed"
    fi

    # Push absorbed changes in a monorepo branch
    log "Pushing local monorepo changes to upstream"
    git push --set-upstream origin $monorepobranch
    [ $? -ne 0 ] && die "[FATAL] push to upstream failed"

    #log "Switching local monorepo to main branch and cleaning up the push branch"
    git checkout -q main
    git branch -D -q "$monorepobranch"
    log "Local subrepo push complete"
}

function mrt_main() {
    POSITIONAL_ARGS=()
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "git-mrt version $VERSION"
                exit 0
                ;;
            -m|--monolocation)
                if [ "$2" ]; then
                    MONOHOME=$2
                    shift 2
                else
                    die 'ERROR: -m|--monolocation requires a non-empty option argument'
                fi
                ;;
            -d|--deploykeyfile)
                if [ "$2" ]; then
                    DEPLOYKEYFILE=$2
                    shift 2
                else
                    die 'ERROR: -d|--deploykeyfile requires a non-empty option argument'
                fi
                ;;
            -a|--allowdirs)
                ALLOWDIRS=1
                shift
                ;;
            clone|pull|push)
                if [ -z ${cmdname+x} ]; then
                    cmdname=$1
                    shift
                else
                    die "ERROR: '$1' command requested but '$cmdname' was already specified"
                fi
                ;;
            -*|--*)
                log 0 "Unknown option '$1'"
                usage
                ;;
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done

    set -- "${POSITIONAL_ARGS[@]}"

    if [ -z ${cmdname+x} ]; then
        log 0 "No command is specified"
        usage
    fi
    "mrt__$cmdname" "$@"
}

mrt_main $@
