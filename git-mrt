#!/bin/bash

# Exit with return code
# $1 - message to output in stderr
# $2 - return code
function die() {
    echo "$1" >&2
    exit ${2:-1}
}

declare -A LOG_LEVELS
LOG_LEVELS=([0]="ERROR" [1]="WARN" [2]="INFO" [3]="DEBUG")

VERBOSITY=2

function log() {
    if [ "$#" -eq 0 ]; then
        die "ASSERT: log() called with no arguments"
    elif [ "$#" -eq 1 ]; then
        # default to INFO level if not set
        local level=2
    else
        local level=${1}
        shift
    fi
    if [ "$VERBOSITY" -ge "$level" ]; then
        printf "[${LOG_LEVELS[$level]}] $@\n"
    fi
}

function usage() {
    printf "Usage: %s [-m|--monolocation <dir>] [-d|--deploykeyfile <file>] command\n" `basename $0`
    echo "
Available options:
  -h or --help                         - show this help
  -m or --monolocation                 - local directory where the monorepo will be cloned
  -d or --deploykeyfile                - private deploy key to use for monorepo clone
  -p or --pinch                        - treat the subdir as a simple set of files and not a repo (no history)
  -n or --nosquash                     - perform history rejoin on clone and do not squash commits on push
  -a or --allowdirs                    - allow creation of new directories in monorepo structure on push

Available commands:
  clone <subdir_in_monorepo>           - extract a monorepo subdirectory as a subtree repo
  push [subdir_in_monorepo]            - push local subtree repo changes as a monorepo branch
  pull [subdir_in_monorepo]            - update local subtree repo from a monorepo subdirectory"
    exit 1
}

# Location to which monorepo is cloned
MONOHOME=~/.monorepo
# Name of the cloned repository
MONODIR=app-deploy-epics
# Actual path to the local monorepo
MONOPATH=$MONOHOME/$MONODIR
# Clone link - https default
MONOHTTPSLINK=https://github.com/NSLS2/$MONODIR.git
# Clone link - when using deploy key
MONOGITLINK=git@github.com:NSLS2/$MONODIR.git

function check_uncommited_changes () {
    log "Checking for uncommited changes in local subrepo"
    num_uncommited_changes=$(git status -s --untracked-files=no | wc -l)
    if [ "$num_uncommited_changes" != "0" ]; then
        git status --untracked-files=no
        die "[FATAL] $PWD is a git repository but has uncommited changes! Commit them first before pushing or pulling"
    fi
}

function sparse_pull_mono() {
    # $1 - subdirectory to sparse-checkout
    log "Creating and validating local monorepo"

    # Remember original dir
    pushd ${PWD} &> /dev/null

    # have to install the package 'git-subtree' for the command 'git subtree'
    git subtree &> /dev/null
    [ $? -ne 129 ] && die "[FATAL] git-subtree is not installed"

    # Make sure that monorepo home dir exists
    if [ ! -d $MONOHOME ]; then
        mkdir -p $MONOHOME
        [ ! -d $MONOHOME ] && die "[FATAL] Failed to create $MONOHOME"
    fi
    cd $MONOHOME

    if [ -d $MONODIR ]; then
        # Sanity check in case if local monorepo dir already exists
        if [ ! -d $MONODIR/.git ]; then
            die "[FATAL] $MONOPATH exists but is not a git repository, determine the cause manually"
        fi
        # Here we know that monodir exists and is a git repo. Check shallowness
        cd $MONODIR
        # TODO: this probably should be reverted if a failure happens later
        local monorepo_is_shallow=$(git rev-parse --is-shallow-repository)
        # If we are shallow but don't want to be, unshallow
        if [ ! -z "${NOSQUASH+x}" ] && [ "$monorepo_is_shallow" = "true" ]; then
            log "Unshallowing the shallow local monorepo since --nosquash is requested"
            git fetch --unshallow origin
        fi
        if [ -z "${NOSQUASH+x}" ] && [ "$monorepo_is_shallow" = "false" ]; then
            #die "[FATAL] Local monorepo is not shallow. Remove $MONOPATH or use --nosquash"
            #log "Local monorepo is not shallow"
            log "Shallowing the local monorepo since --nosquash is not requested"
            git pull --depth 1 origin main
            git gc --prune=all
        fi
        cd $MONOHOME
    fi

    # Clone the monorepo if it is absent
    if [ ! -d $MONODIR ]; then
        # git clone extra args depending on squash preference
        # --nosquash for clone means no shallow clone
        local gceargs=""
        if [ -z "${NOSQUASH+x}" ]; then
            log "Will perform a shallow clone"
            gceargs="--depth 1"
        else
            log "Will perform a full clone"
        fi
        if [ ! "$DEPLOYKEYFILE" ]; then
            log "Cloning monorepo from $MONOHTTPSLINK"
            git clone $gceargs --filter=blob:none --sparse $MONOHTTPSLINK
        else
            log "Cloning monorepo from $MONOGITLINK"
            git clone -c core.sshCommand="/usr/bin/ssh -i $DEPLOYKEYFILE" $gceargs --filter=blob:none --sparse $MONOGITLINK
        fi
        if [ $? -ne 0 ]; then
            die "[FATAL] Monorepo clone failed"
        fi
    fi
    cd $MONODIR

    log "Performing monorepo sparse checkout"
    git sparse-checkout set $1
    [ $? -ne 0 ] && die "[FATAL] Monorepo sparse-checkout failed"

    log "Checking for monorepo updates"
    git pull -q origin main
    [ $? -ne 0 ] && die "[FATAL] Monorepo pull failed"

    # Restore original dir
    popd &> /dev/null
}

function mrt__clone() {
    if [ "$1" ]; then
        local subdirectory=$1
    else
        die 'ASSERT: mrt__clone() is called without subdirectory argument being specified'
    fi

    log "Preparing to extract monorepo subdir as local subrepo"

    local subrepopath="$(pwd)/`basename $subdirectory`"
    [ -d $subrepopath ] && die "[FATAL] `basename $subdirectory` directory already exists"

    sparse_pull_mono $subdirectory

    [ ! -d $MONOPATH/$subdirectory ] && die "[FATAL] Monorepo $MONODIR does not contain subdirectory $subdirectory"

    if [ -n "$PINCH" ]; then
        log "Extracting local subrepo in pinch mode"
        cp -r $MONOPATH/$subdirectory $subrepopath
        [ $? -ne 0 ] && die "[FATAL] Failed to copy files from the monorepo"
        cd $subrepopath
        echo "$subdirectory" > .mrt
    else
        log "Initializing a subrepo"
        mkdir $subrepopath
        [ $? -ne 0 ] && die "[FATAL] Failed to create the subrepo dir"
        cd $subrepopath
        git init -q

        log "Splitting the subdirectory into a monorepo branch"
        cd $MONOPATH
        #git subtree push -P $subdirectory $subrepopath split
        #[ $? -ne 0 ] && die "[FATAL] Failed to push into the local subrepo from the local monorepo"
        git subtree split --annotate='(split) ' -P $subdirectory -b $subdirectory/split
        [ $? -ne 0 ] && die "[FATAL] Failed to perform monorepo subtree split, check subdirectory name"

        log "Pulling the monorepo split branch into the subrepo"
        cd $subrepopath
        git pull -q $MONOPATH $subdirectory/split
        local pull_success=$?

        log "Cleaning up the monorepo split branch"
        cd $MONOPATH
        git branch -q -D $subdirectory/split

        if [ $pull_success -ne 0 ]; then
            die "[FATAL] pull in the subrepo failed"
        fi

        log "Writing subrepo metadata"
        cd $subrepopath
        echo "$subdirectory" > .mrt
        [ ! -f .gitignore ] && touch .gitignore
        grep ^.mrt$ .gitignore &> /dev/null
        if [ $? -eq 1 ]; then
            log "Adding metadata file to .gitignore"
            echo ".mrt" >> .gitignore
        fi
    fi
    log "Local subrepo clone complete"
}

function mrt__pull() {
    log "Preparing to pull local subrepo updates from the monorepo"
    # Remember the working directory
    local subrepopath=$(pwd)
    if [ -f .mrt ]; then
        # Subdir info must be present
        local subdirectory=$(<.mrt)
    # Otherwise use the global base path with the current dir name 
    elif [ ! -z "${GIT_MRT_BASE_PATH+x}" ]; then
        local subdirectory=$GIT_MRT_BASE_PATH/${PWD##*/} 
    else
        die "[FATAL] Cannot find local subrepo metadata and GIT_MRT_BASE_PATH is unset. Was it created by 'git mrt clone'?"
    fi
    # Using this would cause trouble if the dir is not a git repo (possible with --pinch)
    #subrepoloc=$(git rev-parse --show-toplevel)

    sparse_pull_mono $subdirectory

    [ ! -d $MONOPATH/$subdirectory ] && die "[FATAL] Monorepo $MONODIR does not contain subdirectory $subdirectory"

    if [ -n "$PINCH" ]; then
        # Pinch mode - just copy files over
        log "Updating local subrepo in pinch mode"
        cp -r $MONOPATH/$subdirectory/* $subrepopath/.
        [ $? -ne 0 ] && die "[FATAL] Failed to copy files from the monorepo"
    else
        # Subtree mode - split in monorepo and then pull from there
        log "Updating local subrepo from monorepo git subtree split"
        cd $MONOPATH
        git subtree split --annotate='(split) ' -P $subdirectory -b $subdirectory/split
        cd $subrepopath
        log "Pulling local subrepo updates from the local monorepo"
        git pull $MONOPATH $subdirectory/split
        local pull_success=$?

        cd $MONOPATH
        git branch -D -q $subdirectory/split
        cd $subrepopath

        if [ $pull_success -ne 0 ]; then
            die "[FATAL] Failed to pull from the local monorepo"
        fi
    fi
    log "Local subrepo pull complete"
}

function mrt__push() {
    log "Preparing to push local subrepo updates to the upstream monorepo"
    # Remember the working directory
    local subrepopath=$(pwd)

    # Use explicit subdir if specified
    if [ "$1" ]; then
        log "Using specified location as a monorepo subdir"
        local subdirectory=$1
    # Use subdir from metadata if available
    elif [ -f .mrt ]; then
        log "Using monorepo subdir from .mrt local subrepo metadata"
        local subdirectory=$(<.mrt)
    # Otherwise use the global base path with the current dir name 
    elif [ ! -z "${GIT_MRT_BASE_PATH+x}" ]; then
        log "Using monorepo subdir from GIT_MRT_BASE_PATH environment variable"
        local subdirectory=$GIT_MRT_BASE_PATH/${PWD##*/}
    else
        die '[FATAL] Cannot determine target monorepo subdir. Must specify a subdirectory, have a local .mrt file, or have GIT_MRT_BASE_PATH set'
    fi

    log "Determining the relevant local subrepo branch"
    if [ -n "$PINCH" ]; then
        local subrepobranch="pinch"
    else
        # We must be in a valid git repo now
        check_uncommited_changes
        local subrepobranch=$(git rev-parse --abbrev-ref HEAD)
        local subrepoloc=$(git rev-parse --show-toplevel)
    fi

    sparse_pull_mono $subdirectory

    # Check if the containing subdir is already present in the index
    log "Ensuring that no intermediate subdirs will be created in the monorepo by the push"
    cd $MONOPATH
    git ls-files --error-unmatch $(dirname $subdirectory) &> /dev/null
    if [ $? -eq 1 ] && [ ! -n "$ALLOWDIRS" ]; then
        die "[FATAL] Performing the push would create a new intermediate monorepo subdir. \
Create '$(dirname $subdirectory)' subdir in the upstream monorepo directly, \
or allow subdir creation with --allowdirs"
    fi

    # Figure out if split branch exists
    # Do not use yet - it might be helpful to figure out if the local
    # monorepo corresponds to the subrepo, but the check will always fail
    # if we push a not-yet-imported dir
    #SPLITEXISTS=$(git branch | grep -w $subdirectory/split)
    #if [[ ! $SPLITEXISTS ]]; then
    #    die "ERROR: local monorepo doesn't have subrepo split"
    #fi

    log "Switching the local monorepo to a branch to be pushed"
    # Figure out the monorepo branch to work on
    local monorepobranch=$subdirectory/$subrepobranch
    git checkout "$monorepobranch" &> /dev/null || git checkout -b "$monorepobranch"
    [ $? -ne 0 ] && die "[FATAL] branch switch failed, check subdirectory name"

    if [ -n "$PINCH" ]; then
        log "Importing local subrepo files in pinch mode"
        if [ ! -d $MONOPATH/$subdirectory ]; then
            mkdir --parents $MONOPATH/$subdirectory
        fi
        # In pinch mode, copy files and commit directly
        if [ -d $subdirectory ]; then
            cp -r $subrepopath/* $MONOPATH/$subdirectory/.
        else
            cp -r $subrepopath $MONOPATH/$subdirectory
        fi
        cd $MONOPATH/$subdirectory
        git add .
        # TODO: customized commit message
        git commit -m "Pinch commit of subdirectory $subdirectory"
    else
        # git subtree extra args
        local steargs=""
        if [ -z "$NOSQUASH" ]; then
            steargs="--squash"
        fi
        # Subtree mode - commit is created by pull/add
        if [ -d $subdirectory ]; then
            local monorepo_is_shallow=$(git rev-parse --is-shallow-repository)
            # When processing an already imported subrepo, we must unshallow to match histories
            if [ "$monorepo_is_shallow" = "true" ]; then
                log 1 "Unshallowing the shallow local monorepo to match histories"
                git fetch --unshallow origin
            fi
            log "Importing local subrepo changes to the existing monorepo dir with git subtree pull"
            git subtree pull $steargs -P $subdirectory $subrepoloc $subrepobranch
            local pull_success=$?

            if [ "$monorepo_is_shallow" = "true" ]; then
                log 1 "Reverting the local monorepo unshallow"
                git pull --depth 1 origin main
                git gc --prune=all
            fi

            if [ $pull_success -ne 0 ]; then
                git checkout -q main
                git branch -D -q "$monorepobranch"
                die "[FATAL] git subtree pull failed"
            fi
        else
            log "Importing local subrepo changes to a new monorepo dir with git add"
            git subtree add $steargs -P $subdirectory $subrepoloc $subrepobranch
            local add_success=$?

            if [ $add_success -ne 0 ]; then
                git checkout -q main
                git branch -D -q "$monorepobranch"
                die "[FATAL] git subtree add failed"
            fi
        fi
    fi

    # Push absorbed changes in a monorepo branch
    log "Pushing local monorepo changes to upstream"
    git push --set-upstream origin $monorepobranch
    local push_success=$?

    #log "Switching local monorepo to main branch and cleaning up the push branch"
    git checkout -q main
    git branch -D -q "$monorepobranch"

    if [ $push_success -ne 0 ]; then
        die "[FATAL] push to upstream failed"
    fi

    log "Local subrepo push complete"
}

function mrt_main() {
    POSITIONAL_ARGS=()
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -p|--pinch)
                PINCH=1
                shift
                ;;
            -m|--monolocation)
                if [ "$2" ]; then
                    MONOHOME=$2
                    shift 2
                else
                    die 'ERROR: -m|--monolocation requires a non-empty option argument'
                fi
                ;;
            -d|--deploykeyfile)
                if [ "$2" ]; then
                    DEPLOYKEYFILE=$2
                    shift 2
                else
                    die 'ERROR: -d|--deploykeyfile requires a non-empty option argument'
                fi
                ;;
            -n|--nosquash)
                NOSQUASH=1
                shift
                ;;
            -a|--allowdirs)
                ALLOWDIRS=1
                shift
                ;;
            clone|pull|push)
                if [ -z ${cmdname+x} ]; then
                    cmdname=$1
                    shift
                else
                    die "ERROR: '$1' command requested but '$cmdname' was already specified"
                fi
                ;;
            -*|--*)
                log 0 "Unknown option '$1'"
                usage
                ;;
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done

    set -- "${POSITIONAL_ARGS[@]}"

    if [ -z ${cmdname+x} ]; then
        log 0 "No command is specified"
        usage
    fi
    "mrt__$cmdname" "$@"
}

mrt_main $@
